<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英熟語リズムマスター</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Yusei+Magic&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #9c27b0;
            --accent-color: #ffeb3b;
            --text-color: #ffffff;
            --font-title: 'Bangers', cursive;
            --font-body: 'Yusei+Magic', sans-serif;
        }

        body {
            font-family: var(--font-body);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #app-container {
            width: 100%;
            max-width: 420px;
            height: 820px;
            background: linear-gradient(45deg, #333, #111);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(156, 39, 176, 0.5);
            border: 5px solid var(--primary-color);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        #app-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><g fill-opacity="0.1" fill="%239c27b0"><rect x="50" width="50" height="50"/><rect y="50" width="50" height="50"/></g></svg>');
            opacity: 0.3;
        }

        header {
            padding: 15px;
            text-align: center;
            background-color: rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 {
            font-family: var(--font-title);
            font-size: 3rem;
            color: var(--accent-color);
            margin: 0;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0px var(--primary-color), 5px 5px 0px #000;
        }

        #info-bar {
            display: flex;
            justify-content: space-between;
            padding: 5px 15px;
            background-color: rgba(0,0,0,0.3);
            font-size: 1.1rem;
            z-index: 10;
        }
        
        #score, #combo {
            font-family: var(--font-title);
            font-size: 1.5rem;
            color: var(--accent-color);
        }

        #game-screen {
            flex-grow: 1;
            position: relative;
        }

        #lanes {
            display: flex;
            height: 100%;
        }

        .lane {
            flex: 1;
            border-left: 2px dashed rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .lane:last-child {
            border-right: 2px dashed rgba(255, 255, 255, 0.2);
        }

        #judgment-line {
            position: absolute;
            bottom: 80px;
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            box-shadow: 0 0 20px var(--accent-color);
            border-radius: 5px;
        }

        .note {
            position: absolute;
            top: -50px;
            width: 90%;
            left: 5%;
            padding: 10px 0;
            background: linear-gradient(180deg, #e91e63, #9c27b0);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 10px #fff;
            will-change: transform;
        }

        #controls {
            display: flex;
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 80px;
        }

        .control-pad {
            flex: 1;
            background-color: rgba(255,255,255,0.1);
            border-top: 5px solid var(--primary-color);
            margin: 0 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-family: var(--font-title);
            color: var(--accent-color);
            transition: background-color 0.1s;
        }
        
        .control-pad.active {
            background-color: var(--accent-color);
            color: #000;
            box-shadow: 0 -5px 20px var(--accent-color);
        }

        #start-screen, #result-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }

        #result-screen.hidden {
            display: none;
        }

        #start-screen h2, #result-screen h2 {
            font-family: var(--font-title);
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
        }
        
        #result-screen p {
            font-size: 1.5rem;
            margin: 10px 0;
        }

        #start-btn, #retry-btn {
            font-family: var(--font-title);
            font-size: 2rem;
            padding: 15px 40px;
            background-color: var(--accent-color);
            color: #000;
            border: 3px solid #000;
            border-radius: 15px;
            cursor: pointer;
            text-shadow: 1px 1px 0px var(--primary-color);
        }
        
        #idiom-display {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 20;
            font-size: 1.4rem;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: var(--accent-color);
            min-height: 50px;
        }
        
        #idiom-meaning {
            font-size: 1rem;
            color: #fff;
        }

        .feedback-text {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--font-title);
            font-size: 3rem;
            color: var(--accent-color);
            opacity: 0;
            animation: fadeUp 0.5s ease-out;
            text-shadow: 2px 2px 0px var(--primary-color);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -50px); }
        }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="start-screen">
            <h2>英熟語リズムマスター</h2>
            <p>画面上から落ちてくる単語に合わせて、<br>対応するキー (D, F, J, K) を押そう！</p>
            <button id="start-btn">START</button>
        </div>
        
        <div id="result-screen" class="hidden">
            <h2>Result</h2>
            <p>Score: <span id="final-score">0</span></p>
            <p>Max Combo: <span id="max-combo">0</span></p>
            <button id="retry-btn">RETRY</button>
        </div>

        <header>
            <h1>Rhythm Master</h1>
        </header>
        <div id="info-bar">
            <div>Score: <span id="score">0</span></div>
            <div>Combo: <span id="combo">0</span></div>
        </div>
        <div id="idiom-display">
            <div id="current-idiom"></div>
            <div id="idiom-meaning"></div>
        </div>
        <main id="game-screen">
            <div id="lanes">
                <div class="lane" data-key="d"></div>
                <div class="lane" data-key="f"></div>
                <div class="lane" data-key="j"></div>
                <div class="lane" data-key="k"></div>
            </div>
            <div id="judgment-line"></div>
            <div id="controls">
                <div class="control-pad" id="pad-d">D</div>
                <div class="control-pad" id="pad-f">F</div>
                <div class="control-pad" id="pad-j">J</div>
                <div class="control-pad" id="pad-k">K</div>
            </div>
        </main>
    </div>

    <script>
    const idioms = [
        { parts: ["look", "for", "to"], full: "look for to", jpn: "〜を楽しみに待つ" },
        { parts: ["take", "care", "of"], full: "take care of", jpn: "〜の世話をする" },
        { parts: ["be", "good", "at"], full: "be good at", jpn: "〜が得意である" },
        { parts: ["put", "up", "with"], full: "put up with", jpn: "〜を我慢する" },
        { parts: ["run", "out", "of"], full: "run out of", jpn: "〜を使い果たす" },
        { parts: ["ask", "for", ""], full: "ask for", jpn: "��を求める" },
        { parts: ["get", "on", ""], full: "get on", jpn: "（乗り物）に乗る" },
        { parts: ["turn", "on", ""], full: "turn on", jpn: "（スイッチ）を入れる" },
    ];

    const gameScreen = document.getElementById('game-screen');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const currentIdiomEl = document.getElementById('current-idiom');
    const idiomMeaningEl = document.getElementById('idiom-meaning');
    const lanes = document.querySelectorAll('.lane');
    const controlPads = document.querySelectorAll('.control-pad');
    const startScreen = document.getElementById('start-screen');
    const resultScreen = document.getElementById('result-screen');
    const startBtn = document.getElementById('start-btn');
    const retryBtn = document.getElementById('retry-btn');
    
    const keyMap = { 'd': 0, 'f': 1, 'j': 2, 'k': 3 };
    const fallSpeed = 3000; // ms to fall from top to bottom
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let activeNotes = [];
    let currentIdiomIndex = -1;
    let currentPartIndex = 0;
    let gameInterval;
    let isPlaying = false;

    function initGame() {
        score = 0;
        combo = 0;
        maxCombo = 0;
        activeNotes = [];
        currentIdiomIndex = -1;
        scoreEl.textContent = 0;
        comboEl.textContent = 0;
        currentIdiomEl.textContent = "";
        idiomMeaningEl.textContent = "";
        resultScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        document.querySelectorAll('.note').forEach(n => n.remove());
    }

    function startGame() {
        isPlaying = true;
        startScreen.classList.add('hidden');
        nextIdiom();
        gameInterval = setInterval(gameLoop, 1000); // Check for game end
    }

    function nextIdiom() {
        if (!isPlaying) return;
        currentIdiomIndex++;
        if (currentIdiomIndex >= idioms.length) {
            endGame();
            return;
        }
        currentPartIndex = 0;
        const idiom = idioms[currentIdiomIndex];
        currentIdiomEl.textContent = "_ ".repeat(idiom.parts.filter(p => p).length);
        idiomMeaningEl.textContent = idiom.jpn;
        spawnNextPart();
    }
    
    function spawnNextPart() {
        if (!isPlaying) return;
        const idiom = idioms[currentIdiomIndex];
        if (currentPartIndex >= idiom.parts.length || !idiom.parts[currentPartIndex]) {
            // Idiom complete
            setTimeout(nextIdiom, 1000);
            return;
        }
        
        const part = idiom.parts[currentPartIndex];
        const laneIndex = Math.floor(Math.random() * 4);
        createNote(part, laneIndex);
    }

    function createNote(text, laneIndex) {
        const note = document.createElement('div');
        note.className = 'note';
        note.textContent = text;
        note.dataset.key = Object.keys(keyMap)[laneIndex];
        note.dataset.spawnTime = Date.now();
        
        lanes[laneIndex].appendChild(note);
        activeNotes.push(note);

        const animation = note.animate([
            { transform: 'translateY(0px)' },
            { transform: `translateY(${gameScreen.offsetHeight}px)` }
        ], {
            duration: fallSpeed,
            easing: 'linear'
        });
        
        animation.onfinish = () => {
            if (activeNotes.includes(note)) {
                miss(note);
            }
        };
    }

    function handleKeyPress(key) {
        if (!isPlaying) return;
        
        const pad = document.getElementById(`pad-${key}`);
        if (pad) {
            pad.classList.add('active');
            setTimeout(() => pad.classList.remove('active'), 100);
        }

        const judgmentLineY = gameScreen.offsetHeight - 80;
        const targetNote = activeNotes.find(note => {
            if (note.dataset.key !== key) return false;
            const noteRect = note.getBoundingClientRect();
            const gameRect = gameScreen.getBoundingClientRect();
            const noteY = noteRect.top - gameRect.top + noteRect.height / 2;
            return Math.abs(noteY - judgmentLineY) < 50; // 50px hit window
        });

        if (targetNote) {
            hit(targetNote);
        } else {
            // Penalty for wrong key press? Maybe not.
        }
    }

    function hit(note) {
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        score += 100 + (combo * 10);
        scoreEl.textContent = score;
        comboEl.textContent = combo;
        
        showFeedback("Perfect!");

        const idiom = idioms[currentIdiomIndex];
        const parts = currentIdiomEl.textContent.split(" ");
        parts[currentPartIndex] = idiom.parts[currentPartIndex];
        currentIdiomEl.textContent = parts.join(" ");

        currentPartIndex++;
        removeNote(note);
        spawnNextPart();
    }

    function miss(note) {
        combo = 0;
        comboEl.textContent = combo;
        showFeedback("Miss...");
        removeNote(note);
        
        // Restart the current part
        spawnNextPart();
    }
    
    function removeNote(note) {
        activeNotes = activeNotes.filter(n => n !== note);
        note.remove();
    }

    function showFeedback(text) {
        const feedback = document.createElement('div');
        feedback.className = 'feedback-text';
        feedback.textContent = text;
        gameScreen.appendChild(feedback);
        setTimeout(() => feedback.remove(), 500);
    }
    
    function gameLoop() {
        // This is mainly for checking game end condition now
    }

    function endGame() {
        isPlaying = false;
        clearInterval(gameInterval);
        document.getElementById('final-score').textContent = score;
        document.getElementById('max-combo').textContent = maxCombo;
        resultScreen.classList.remove('hidden');
    }

    document.addEventListener('keydown', (e) => {
        if (keyMap.hasOwnProperty(e.key)) {
            handleKeyPress(e.key);
        }
    });
    
    controlPads.forEach(pad => {
        pad.addEventListener('mousedown', () => {
            const key = pad.id.split('-')[1];
            handleKeyPress(key);
        });
    });

    startBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', initGame);

    initGame();
    </script>
</body>
</html>